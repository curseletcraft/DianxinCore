package com.dianxin.core.api.config.properties;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

public class EmbeddedPropertiesConfigurationImpl implements EmbeddedPropertiesConfiguration {

    private final Properties properties;
    private final String splitter;
    private File currentFile;
    private final Logger logger = LoggerFactory.getLogger(EmbeddedPropertiesConfigurationImpl.class);

    protected EmbeddedPropertiesConfigurationImpl(@NotNull File file, @Nullable String splitter) {
        this.properties = new Properties();
        this.splitter = (splitter == null || splitter.isEmpty()) ? "," : splitter; // default là dấu phẩy nếu null
        this.currentFile = file;

        // Tự động load nếu file tồn tại
        if (file.exists()) {
            try {
                load(file);
            } catch (IOException e) {
                logger.error("Cannot load configuration in file {}", file.getPath(), e);
            }
        }
    }

    @Override
    public void load(File file) throws IOException {
        this.currentFile = file;
        try (InputStreamReader reader = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8)) {
            properties.load(reader);
        }
    }

    @Override
    public void save(File file) throws IOException {
        try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8)) {
            // Store properties with a comment
            properties.store(writer, "Auto-generated by DianxinCore PropertiesConfiguration");
        }
    }

    public void reload() throws IOException {
        if (currentFile != null && currentFile.exists()) {
            properties.clear(); // Xóa cache cũ
            load(currentFile);
        }
    }

    // --- Core Getters / Setters ---

    @Override
    public Object get(String path) {
        return properties.getProperty(path);
    }

    @Override
    public Object get(String path, Object def) {
        String val = properties.getProperty(path);
        return (val != null) ? val : def;
    }

    @Override
    public void set(String path, Object value) {
        if (value == null) {
            properties.remove(path);
        } else {
            // Nếu value là List, ta tự động join nó lại thành chuỗi bằng splitter
            if (value instanceof List) {
                String joined = ((List<?>) value).stream()
                        .map(String::valueOf)
                        .collect(Collectors.joining(splitter));
                properties.setProperty(path, joined);
            } else {
                properties.setProperty(path, String.valueOf(value));
            }
        }
    }

    @Override
    public boolean contains(String path) {
        return properties.containsKey(path);
    }

    // --- Typed Getters ---

    @Override
    public String getString(String path) {
        return properties.getProperty(path);
    }

    @Override
    public String getString(String path, String def) {
        return properties.getProperty(path, def);
    }

    @Override
    public int getInt(String path) {
        return getInt(path, 0);
    }

    @Override
    public int getInt(String path, int def) {
        String val = getString(path);
        try {
            return (val != null) ? Integer.parseInt(val) : def;
        } catch (NumberFormatException e) {
            return def;
        }
    }

    @Override
    public double getDouble(String path) {
        return getDouble(path, 0.0);
    }

    @Override
    public double getDouble(String path, double def) {
        String val = getString(path);
        try {
            return (val != null) ? Double.parseDouble(val) : def;
        } catch (NumberFormatException e) {
            return def;
        }
    }

    @Override
    public boolean getBoolean(String path) {
        return getBoolean(path, false);
    }

    @Override
    public boolean getBoolean(String path, boolean def) {
        String val = getString(path);
        return (val != null) ? Boolean.parseBoolean(val) : def;
    }

    // --- List Handling (Logic Splitter) ---

    @Override
    public List<?> getList(String path) {
        return getStringList(path); // Properties cơ bản chỉ lưu chuỗi, nên list cũng là list string
    }

    @Override
    public List<String> getStringList(String path) {
        String val = getString(path);
        if (val == null || val.isEmpty()) {
            return new ArrayList<>();
        }

        // Tách chuỗi dựa trên biến splitter
        // Ví dụ: val = "admin|mod|user", splitter = "|" -> ["admin", "mod", "user"]
        // Sử dụng Pattern.quote để tránh lỗi nếu splitter là ký tự đặc biệt regex (ví dụ dấu |)
        String[] parts = val.split(java.util.regex.Pattern.quote(splitter));

        List<String> list = new ArrayList<>();
        for (String part : parts) {
            list.add(part.trim()); // Trim khoảng trắng thừa cho sạch
        }
        return list;
    }
}